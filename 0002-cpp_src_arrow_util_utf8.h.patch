--- apache-arrow-8.0.0/cpp/src/arrow/util/utf8.h	2022-05-03 12:59:12.000000000 -0400
+++ apache-arrow-7.0.0/cpp/src/arrow/util/utf8.h	2022-01-28 19:09:12.000000000 -0500
@@ -241,7 +241,11 @@
 
 #if defined(ARROW_HAVE_NEON) || defined(ARROW_HAVE_SSE4_2)
 static inline bool ValidateAsciiSimd(const uint8_t* data, int64_t len) {
-  using simd_batch = xsimd::make_sized_batch_t<int8_t, 16>;
+#ifdef ARROW_HAVE_NEON
+  using simd_batch = xsimd::batch<int8_t, xsimd::neon64>;
+#else
+  using simd_batch = xsimd::batch<int8_t, xsimd::sse4_2>;
+#endif
 
   if (len >= 32) {
     const simd_batch zero(static_cast<int8_t>(0));
--- apache-arrow-8.0.0/cpp/src/arrow/csv/writer.cc.orig	2022-05-08 17:00:08.860430555 -0400
+++ apache-arrow-8.0.0/cpp/src/arrow/csv/writer.cc	2022-05-08 17:02:42.526756723 -0400
@@ -217,7 +217,12 @@
 #if defined(ARROW_HAVE_SSE4_2) || defined(ARROW_HAVE_NEON)
     // _mm_cmpistrc gives slightly better performance than the naive approach,
     // probably doesn't deserve the effort
-    using simd_batch = xsimd::make_sized_batch_t<uint8_t, 16>;
+#ifdef ARROW_HAVE_NEON
+    using simd_batch = xsimd::batch<int8_t, xsimd::neon64>;
+#else
+    using simd_batch = xsimd::batch<int8_t, xsimd::sse4_2>;
+#endif
+
     while ((offset + 16) <= buffer_size) {
       const auto v = simd_batch::load_unaligned(data + offset);
       if (xsimd::any((v == '\n') | (v == '\r') | (v == '"') | (v == delimiter))) {
--- apache-arrow-8.0.0/cpp/src/arrow/util/bpacking_simd_codegen.py.orig	2022-05-08 17:19:16.349459649 -0400
+++ apache-arrow-8.0.0/cpp/src/arrow/util/bpacking_simd_codegen.py	2022-05-08 17:19:56.813754872 -0400
@@ -176,7 +176,7 @@
         template <DispatchLevel level>
         struct {struct_name} {{
 
-        using simd_batch = xsimd::make_sized_batch_t<uint32_t, {simd_width//32}>;
+        using simd_batch = xsimd::batch<uint32_t, simd_arch>;
         """))
 
     gen = UnpackGenerator(simd_width)
--- apache-arrow-8.0.0/cpp/src/arrow/util/bpacking_simd128_generated.h.orig	2022-05-08 17:32:49.743300777 -0400
+++ apache-arrow-8.0.0/cpp/src/arrow/util/bpacking_simd128_generated.h	2022-05-08 17:36:05.429945990 -0400
@@ -36,7 +36,13 @@
 template <DispatchLevel level>
 struct UnpackBits128 {
 
-using simd_batch = xsimd::make_sized_batch_t<uint32_t, 4>;
+#ifdef ARROW_HAVE_NEON
+using simd_arch = xsimd::neon64;
+#else
+using simd_arch = xsimd::sse4_2;
+#endif
+
+using simd_batch = xsimd::batch<uint32_t, simd_arch>;
 
 inline static const uint32_t* unpack0_32(const uint32_t* in, uint32_t* out) {
   memset(out, 0x0, 32 * sizeof(*out));
--- apache-arrow-8.0.0/cpp/src/arrow/util/bpacking_simd256_generated.h.orig	2022-05-08 17:31:13.627966647 -0400
+++ apache-arrow-8.0.0/cpp/src/arrow/util/bpacking_simd256_generated.h	2022-05-08 17:38:01.045963910 -0400
@@ -36,7 +36,8 @@
 template <DispatchLevel level>
 struct UnpackBits256 {
 
-using simd_batch = xsimd::make_sized_batch_t<uint32_t, 8>;
+using simd_arch = xsimd::avx2;
+using simd_batch = xsimd::batch<uint32_t, simd_arch>;
 
 inline static const uint32_t* unpack0_32(const uint32_t* in, uint32_t* out) {
   memset(out, 0x0, 32 * sizeof(*out));
--- apache-arrow-8.0.0/cpp/src/arrow/util/bpacking_simd512_generated.h.orig	2022-05-08 17:32:56.763180428 -0400
+++ apache-arrow-8.0.0/cpp/src/arrow/util/bpacking_simd512_generated.h	2022-05-08 17:37:35.072409190 -0400
@@ -36,7 +36,8 @@
 template <DispatchLevel level>
 struct UnpackBits512 {
 
-using simd_batch = xsimd::make_sized_batch_t<uint32_t, 16>;
+using simd_arch = xsimd::avx512bw;
+using simd_batch = xsimd::batch<uint32_t, simd_arch>;
 
 inline static const uint32_t* unpack0_32(const uint32_t* in, uint32_t* out) {
   memset(out, 0x0, 32 * sizeof(*out));
